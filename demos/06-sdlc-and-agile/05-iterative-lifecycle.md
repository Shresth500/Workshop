# Iterative Lifecycle in SDLC

### Overview
The **Iterative lifecycle** is a methodology in the Software Development Life Cycle (SDLC) where the development process is split into small, manageable iterations or cycles. Each iteration consists of planning, design, development, and testing, and results in a working version (prototype) of the software. This cycle repeats until the software is fully developed and refined.

The key concept is **incremental improvement**: each iteration refines and improves the software based on feedback and lessons learned from previous iterations.

### Key Phases of the Iterative Lifecycle

1. **Requirement Gathering**
   - In the initial phase, high-level requirements are gathered and understood.
   - Unlike the Waterfall model, detailed requirements for the entire project are not defined upfront. Instead, they evolve through iterations.

2. **Design**
   - A basic design is created for the first iteration.
   - In subsequent iterations, the design is refined and extended as more requirements are understood and implemented.

3. **Development**
   - Development takes place in increments or iterations.
   - A working portion of the product is developed in each iteration, starting with the most important or foundational features.
   
4. **Testing**
   - Each iteration undergoes testing to ensure that the newly developed functionality works and integrates with the existing components.
   - Testing is done continuously in every iteration, catching bugs early in the process.

5. **Feedback and Evaluation**
   - After each iteration, the product is evaluated based on user feedback, testing results, and performance metrics.
   - The feedback drives changes or improvements in subsequent iterations.

6. **Repeat**
   - The process repeats with adjustments made based on feedback and newly discovered requirements, allowing the product to evolve and improve with each cycle.

7. **Final Product**
   - After several iterations, the final product emerges as a result of continuous refinement and addition of features over time.

### Characteristics of the Iterative Lifecycle

- **Continuous Improvement**: Each iteration provides an opportunity to refine and improve the software incrementally.
- **Flexibility**: Changes and new requirements can be incorporated in the middle of development.
- **Early Detection of Issues**: Since testing is done in every iteration, bugs and issues can be identified and resolved early.
- **User Feedback**: The development team can collect user feedback at every stage, allowing the product to align better with user needs.
- **Partial Working Software**: After each iteration, a functional version of the software is available, even if itâ€™s not the final product.

### Advantages

- **Early Delivery**: A working version of the product can be delivered early, even if it's not feature-complete.
- **Risk Reduction**: By testing and integrating frequently, the risks associated with project failure are reduced.
- **Flexibility to Changes**: Changes in requirements can be incorporated easily between iterations.
- **Improved Quality**: Frequent testing and user feedback lead to better software quality.

### Disadvantages

- **Unclear End Goal**: Since the software evolves with each iteration, the end product may not be clearly defined at the start.
- **Overlapping Phases**: The phases in each iteration often overlap, making planning and management more complex.
- **Resource Intensive**: Repeated testing, rework, and evaluation require more resources and time in the long run.

### When to Use the Iterative Lifecycle

- When requirements are not fully known or are expected to change during development.
- For complex projects that need continuous refinement and feedback.
- When early versions of the product need to be delivered to the market or to stakeholders for review.

### Example of Iterative Development

1. **Iteration 1**:
   - Develop core features of the product.
   - Perform basic testing.
   - Deliver a basic prototype for feedback.

2. **Iteration 2**:
   - Incorporate feedback from iteration 1.
   - Add new features or refine existing ones.
   - Perform another round of testing and feedback collection.

3. **Iteration 3 and beyond**:
   - Continue refining, adding features, and addressing issues in each iteration.
   - Eventually, produce the final, polished product.

### Conclusion

The **Iterative lifecycle** is a flexible and adaptive approach to software development, suitable for projects where requirements evolve or are not fully defined upfront. It focuses on delivering working software in increments while continuously refining and improving the product through feedback and testing.
